# Advertised hostname.
druid.host=coordinator
# The name of the service. This is used as a dimension when emitting metrics and alerts to differentiate between the various services.
druid.service=druid/coordinator
# This is the port to actually listen on; unless port mapping is used, this will be the same port as is on druid.host.
druid.port=8081

# The operation of the Coordinator works on the assumption that it has an up-to-date view of the state of the world when it runs, the current ZK interaction code, however, is written in a way that doesn’t allow the Coordinator to know for a fact that it’s done loading the current state of the world. This delay is a hack to give it enough time to believe that it has all the data.
druid.coordinator.startDelay=PT60S
# The run period for the coordinator. The coordinator’s operates by maintaining the current state of the world in memory and periodically looking at the set of segments available and segments being served to make decisions about whether any changes need to be made to the data topology. This property sets the delay between each of these runs.
druid.coordinator.period=PT20S

# Boolean flag for whether or not the coordinator should try and merge small segments into a more optimal segment size.
druid.coordinator.merge.on=true

druid.monitoring.monitors=["com.metamx.metrics.JvmMonitor","io.druid.client.cache.CacheMonitor"]
# Distribute data evenly among historicals
druid.coordinator.balancer.strategy=diskNormalized

# Might as well...
druid.coordinator.asOverlord.enabled=true
druid.coordinator.asOverlord.overlordService=druid/overlord

# Sleep this long before starting overlord queue management. This can be useful to give a cluster time to re-orient itself after e.g. a widespread network issue.
druid.indexer.queue.startDelay=PT30S
# Sleep this long when overlord queue management throws an exception before trying again.
druid.indexer.queue.restartDelay=PT30S

druid.indexer.runner.type=remote
druid.indexer.storage.type=metadata
